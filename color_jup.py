# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1N_QPBvhwsKT5M7un8ZGRKgW5K5TFmzQG
"""

import os
import random
import numpy as np
from PIL import Image

import tensorflow as tf
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Dense, Flatten, Activation, Conv2DTranspose
from keras.layers import Conv2D, Activation, BatchNormalization
from tensorflow.keras.models import Model,load_model,Sequential
from sklearn.metrics import confusion_matrix
from sklearn.preprocessing import Binarizer
from tensorflow.keras.preprocessing.image import img_to_array, load_img

import matplotlib.pyplot as plt
import sys
from keras.datasets import cifar100
import cv2

epochs = 20
PART_SIZE=32
batches=100
data_test_ratio=0.2

def ssim_metric(y_true, y_pred):
    return tf.reduce_mean(tf.image.ssim(y_true, y_pred, max_val=1.0))

def load_data(path, test_ratio=data_test_ratio, patch_size=(PART_SIZE, PART_SIZE),num_rot=50):
    file_list = os.listdir(path)
    random.shuffle(file_list)
    num_test = int(len(file_list) * test_ratio)

    X_test = []
    Y_test = []
    X_train = []
    Y_train = []

    for file_name in file_list:
        file_path = os.path.join(path, file_name)
        image = Image.open(file_path)
        image = image.resize(patch_size)

        if image.mode != 'RGB':
            image = image.convert('RGB')

        for angle in range(0, 360, int(360 / num_rot)):
            bw_rotated = image.convert('L').rotate(angle)
            color_rotated = image.rotate(angle)

            bw_image_np = np.array(bw_rotated) / 255.0
            bw_image_np = np.expand_dims(bw_image_np, axis=-1)
            color_image_np = np.array(color_rotated) / 255.0

            if file_name in file_list[:num_test]:
                X_test.append(bw_image_np)
                Y_test.append(color_image_np)
            else:
                X_train.append(bw_image_np)
                Y_train.append(color_image_np)

    X_test = np.array(X_test)
    Y_test = np.array(Y_test)
    X_train = np.array(X_train)
    Y_train = np.array(Y_train)

    return X_test, Y_test, X_train, Y_train

model.summary()

def create_model(input_shape):
    model = Sequential()
    filters=[64]
    first = True

    for f in filters:
      if first:
        model.add(Conv2D(f, (3, 3), padding='same'))
        first=False
      else:
        model.add(Conv2D(f, (3, 3), padding='same'))
      model.add(BatchNormalization())
      model.add(Activation('relu'))

    for f in filters[-1:]:
      print(f)
      model.add(Conv2DTranspose(f, (3, 3), padding='same'))
      model.add(Activation('relu'))

    model.add(Conv2DTranspose(3, (3, 3), padding='same'))
    model.add(Activation('sigmoid'))

    model.compile(loss='mean_squared_error', optimizer='adam', metrics=[ssim_metric])
    return model

X_test, Y_test, X_train, Y_train = load_data('zdjecia_test', patch_size=(PART_SIZE, PART_SIZE))
print('x train shape', X_train.shape)
print('x train shape', X_test.shape)
model = create_model((PART_SIZE, PART_SIZE,1))
history = model.fit(X_train, Y_train, validation_data=(X_test, Y_test), batch_size=batches, epochs=epochs)

model.save('model_1.h5')

plt.figure(figsize=(10, 5))
plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.title('Model loss')
plt.ylabel('Loss')
plt.xlabel('Epoch')
plt.legend(['Train', 'Validation'], loc='upper right')
plt.show()

obraz = load_img('o.jpg', target_size=(256, 256))
obraz_1 =obraz
bw_image = obraz.convert('L')
obraz = img_to_array(bw_image)
obraz = obraz / 255.0  # Normalizacja
obraz = np.expand_dims(obraz, axis=0)
wynik = model.predict(obraz)
wynikowy_obraz = wynik[0]
wynikowy_obraz = (wynikowy_obraz * 255).astype(np.uint8)
fig, axes = plt.subplots(1, 3, figsize=(12, 6))  # 1 wiersz, 2 kolumny, rozmiar figury 12x6 cali

# Wyświetlanie pierwszego obrazu (wynikowego obrazu w skali szarości)
axes[2].imshow(wynikowy_obraz)
axes[2].set_title('Wynikowy Obraz')
axes[2].axis('off')

# Wyświetlanie drugiego obrazu (oryginalnego obrazu kolorowego)
axes[0].imshow(obraz_1)
axes[0].set_title('Obraz 1')
axes[0].axis('off')

# Wyświetlanie trzeciego obrazu (obrazu wejściowego w skali szarości)
axes[1].imshow(bw_image, cmap='gray')
axes[1].set_title('Czarno-biały')
axes[1].axis('off')

# Wyświetlenie wykresu
plt.show()